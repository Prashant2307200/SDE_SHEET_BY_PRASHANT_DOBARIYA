double minimiseMaxDistance(vector<int> &arr, int k){
	int n = arr.size();
	vector<int> isPlace(n-1,0);
	for(int gasStations = 1; gasStations <= k; ++gasStations){
		long double maxSecLen = -1;
		int maxIdx = -1;
		for(int i = 0; i < n-1; ++i){
			long double diff = (arr[i+1]-arr[i]);
			long double secLen = diff/((long double)isPlace[i]+1);
			if(secLen > maxSecLen){
				maxSecLen = secLen;
				maxIdx = i;
			}
		}
        isPlace[maxIdx]++;
	}
    long double maxAns = -1;
	for(int i = 0; i < n-1; ++i){
		long double diff = arr[i+1]-arr[i];
		long double secLen = diff/((long double)1+isPlace[i]);
		maxAns = max(maxAns,secLen);
	}
    return maxAns;
}

double minimiseMaxDistance(vector<int> &arr, int k){
	int n = arr.size();
	vector<int> isPlace(n-1,0);
	priority_queue<pair<long double ,int>> pq;
	for(int i = 0; i < n-1; ++i){
		pq.push({ arr[i+1]-arr[i] ,i });
	}
    for(int gasStations = 1; gasStations <= k; ++gasStations){
		auto tp = pq.top();
		pq.pop();
		int secIdx = tp.second;
		isPlace[secIdx]++;
		long double iniDiff = arr[secIdx+1]-arr[secIdx];
		long double newSecLen = iniDiff/((long double)1+isPlace[secIdx]);
		pq.push({ newSecLen ,secIdx });
	}
    return pq.top().first;
}

int noOfReqGasStation(vector<int> &arr,long double maxDist){
	int cnt = 0 ,n = arr.size();
	for(int i = 1; i < n; ++i){
		int noInBw = (arr[i]-arr[i-1])/maxDist;
		if((arr[i]-arr[i-1]) == noInBw*maxDist){
			noInBw--;
		}
        cnt += noInBw;
	}
    return cnt;
}
double minimiseMaxDistance(vector<int> &arr, int k){
	int n = arr.size();
	long double low = 0 ,high = 0;
	for(int i = 0; i < n-1; ++i){
		high = max(high,(long double)arr[i+1]-arr[i]);
	}
    long double diff = 1e-6;
	while(high-low > diff){
		long double mid = (high+low)/2.0;
		int cnt = noOfReqGasStation(arr,mid);
		if(cnt > k){
			low = mid;
		}else{
			high = mid;
		}
	}
    return high;
}

double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int i =  0 ,j = 0; 
    int n = nums1.size() ,m = nums2. size() ,k = 0;
    vector<int> nums(n+m);
    while(i < n || j < m){
        if(i < n && j < m){
            if(nums1[i] < nums2[j]){
                nums[k++] = nums1[i++];
            }
            else{
                nums[k++] = nums2[j++];
            }
        }
        else if(i < n){
            nums[k++] = nums1[i++];
        }
        else if(j < m){
            nums[k++] = nums2[j++];
        }
    }
    if(k%2 == 1){
        return nums[k/2];
    }
    else{
        return (nums[k/2] + nums[k/2 - 1])/2.0;
    }
}

double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int i =  0 ,j = 0;
    int n = nums1.size() ,m = nums2. size() ,k = 0;
    int idx1elm = -1 ,idx2elm = -1;
    int idx2 = (n+m)/2;
    int idx1 = idx2-1;
    while(i < n || j < m){
        if(i < n && j < m){
            if(nums1[i] < nums2[j]){
                if(k == idx1)  idx1elm = nums1[i];
                if(k == idx2)  idx2elm = nums1[i];
                i++; 
            }
            else{
                if(k == idx1)  idx1elm = nums2[j];
                if(k == idx2)  idx2elm = nums2[j];
                j++;
            }
        }
        else if(i < n){
            if(k == idx1)  idx1elm = nums1[i];
            if(k == idx2)  idx2elm = nums1[i];
            i++;
        }
        else if(j < m){
            if(k == idx1)  idx1elm = nums2[j];
            if(k == idx2)  idx2elm = nums2[j];
            j++;
        }
        k++;
    }
    if(k%2 == 1){
        return idx2elm;
    }
    else{
        return (idx1elm + idx2elm)/2.0;
    }
}

double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int n1 = nums1.size() ,n2 = nums2.size();
    int n = n1+n2+1;
    if(n1 > n2) return findMedianSortedArrays(nums2,nums1);
    int low = 0 ,high = n1;
    while(low <= high){
        int P1 = (low+high)/2;
        int P2 = n/2 - P1;
        int x1 = P1 == 0  ? INT_MIN : nums1[P1-1];
        int x2 = P2 == 0  ? INT_MIN : nums2[P2-1];
        int x3 = P1 == n1 ? INT_MAX : nums1[P1];
        int x4 = P2 == n2 ? INT_MAX : nums2[P2];
        if(x1 <= x4 && x2 <= x3){
            if((n1+n2)%2 == 1){
                return max(x1,x2);
            }   
            else{
                return (max(x1,x2)+min(x3,x4))/2.0;
            }
        }
        else if(x1 > x4){
            high = P1-1;
        }
        else{
            low = P1+1;
        }
    }return -1;
}

int kthElement(vector<int> &nums1, vector<int>& nums2, int n1, int n2, int k){
    if(n1 > n2) return kthElement(nums2,nums1,n2,n1,k);
    int low = max(0,k-n2) ,high = min(k,n1);
    while(low <= high){
        int P1 = (low+high)/2;
        int P2 = k - P1;
        int x1 = P1 == 0  ? INT_MIN : nums1[P1-1];
        int x2 = P2 == 0  ? INT_MIN : nums2[P2-1];
        int x3 = P1 == n1 ? INT_MAX : nums1[P1];
        int x4 = P2 == n2 ? INT_MAX : nums2[P2];
        if(x1 <= x4 && x2 <= x3){
            return max(x1,x2);
        }
        else if(x1 > x4){
            high = P1-1;
        }
        else{
            low = P1+1;
        }
    }
    return -1;
}

int n = matrix.size() ,m = matrix[0].size();
for(int i = 0; i < n; ++i){
    for(int j = 0; j < m; ++j){
        if(matrix[i][j] == target){
            return 1;
        } 
    }
}return 0;

bool searchMatrix(vector<vector<int>>& matrix, int target) {    
    int n = matrix.size() ,m = matrix[0].size();
    int lowy = 0 ,highy = n-1;
    int lowx = 0 ,highx = m-1;
    while(lowy <= highy){
        int midy = (lowy+highy)/2;
        if(matrix[midy][0] <= target && target <= matrix[midy][m-1]){
            while(lowx <= highx){
                int midx = (lowx+highx)/2;
                if(matrix[midy][midx] == target){
                    return 1;
                }
                else if(matrix[midy][midx] > target){
                    highx = midx-1;
                }
                else{
                    lowx = midx+1;
                }
            }
            return 0;
        }
        else if(matrix[midy][0] > target){
            highy = midy-1;
        }
        else{
            lowy = midy+1;
        }
    }
    return 0;
}

bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int n = matrix.size() ,m = matrix[0].size();
    int row = 0 ,col = m-1;
    while(row < n && col >= 0){
        if(matrix[row][col] == target){
            return 1;
        }else if(matrix[row][col] > target){
            col--;
        }else{
            row++;
        }
    }return 0;
}

int rowWithMax1s(vector<vector<int>> &matrix, int n, int m){
    int maxCnt = 0 ,idx = -1;
    for(int i = 0; i < n; ++i){
        int cnt = 0;
        for(int j = 0; j < m; ++j){
            cnt += matrix[i][j];
            if(cnt > maxCnt){
                maxCnt = cnt;
                idx = i;
            }
        }
    }
    return idx;
}

int rowWithMax1s(vector<vector<int>> &matrix, int n, int m){
    int maxCnt = 0 ,idx = -1;
    for(int i = 0; i < n; ++i){
        int low = 0 ,high = m-1;
        while(low <= high){
            int mid = (low+high)/2;
            if(matrix[i][mid] == 1){
                high = mid-1;
            }
            else{
                low = mid+1;
            }
        }
        int cnt = m-low;
        if(cnt > maxCnt){
            maxCnt = cnt;
            idx = i;
        }
    }
    return idx;
}

class Solution {
    int findMaxIdx(vector<vector<int>>& mat,int n,int m,int col){
        int maxVal = -1 ,maxIdx = -1;
        for(int i = 0; i < n; ++i){
            if(mat[i][col] > maxVal){
                maxVal = mat[i][col];
                maxIdx = i;
            }
        }
        return maxIdx;
    }
public:
    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        int n = mat.size() ,m = mat[0].size();
        int low = 0 ,high = m-1;
        while(low <= high){
            int col = (low+high)/2;
            int maxRowIdx = findMaxIdx(mat,n,m,col);
            int left = col-1 >= 0? mat[maxRowIdx][col-1] : -1;
            int right = col+1 < m? mat[maxRowIdx][col+1] : -1;
            if(mat[maxRowIdx][col] > left && mat[maxRowIdx][col] > right){
                return {maxRowIdx,col};
            }
            else if(mat[maxRowIdx][col] < left){
                high = col-1;
            }
            else{
                low = col+1;
            }
        }
        return {-1,-1};
    }
};

int median(vector<vector<int>> &matrix, int n, int m) {
    vector<int> v;
    for(auto& arr : matrix){
        for(auto& elm : arr){
            v.push_back(elm);
        }
    }
    sort(v.begin(),v.end());
    return v[(n*m)/2];
}

int countSmallerThanMid(vector<int> &row, int midian){
    int low = 0, high = row.size() - 1;
    while (low <= high){
        int mid = (l + h) >> 1;
        if (row[mid] <= midian){
            low = mid + 1;
        }
        else{
            high = mid - 1;
        }
  }
  return low;
}
int findMedian(vector<vector<int>> &A){
    int low = *min_element(A.begin(),a.end());
    int high = *max_element(A.begin(),a.end());
    int n = A.size() ,m = A[0].size();
    while (low <= high){
        int mid = (low + high) >> 1;
        int cnt = 0;
        for (int i = 0; i < n; i++){
            cnt += countSmallerThanMid(A[i], mid);
        }
        if (cnt <= (n * m) / 2)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return low;
}
